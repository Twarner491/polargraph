"""
G-code generator for converting turtle paths to G-code.
"""

from typing import List
from .turtle import Turtle, Point
from .plotter_settings import PlotterSettings


class GCodeGenerator:
    """Generates G-code from Turtle paths."""
    
    def __init__(self, settings: PlotterSettings):
        self.settings = settings
    
    def turtle_to_gcode(self, turtle: Turtle) -> List[str]:
        """Convert a Turtle's paths to G-code."""
        gcode = []
        
        # Header
        gcode.append('; Generated by Polargraph Web Interface')
        gcode.append('; Makelangelo-compatible G-code')
        gcode.append('')
        gcode.append('G90 ; Absolute positioning')
        gcode.append(f'G0 F{self.settings.get("feed_rate_travel")} ; Set travel speed')
        
        # Pen up to start
        gcode.append(self.settings.get_pen_up_command())
        
        last_point = None
        pen_is_up = True
        
        for layer in turtle.layers:
            for line in layer.lines:
                if len(line.points) < 2:
                    continue
                
                # Move to start of line (travel move)
                start = line.points[0]
                
                if last_point is None or self._distance(last_point, start) > 0.1:
                    # Pen up if not already
                    if not pen_is_up:
                        gcode.append(self.settings.get_pen_up_command())
                        pen_is_up = True
                    
                    # Travel to start
                    gcode.append(f'G0 X{start.x:.3f} Y{start.y:.3f} F{self.settings.get("feed_rate_travel")}')
                
                # Pen down
                if pen_is_up:
                    gcode.append(self.settings.get_pen_down_command())
                    pen_is_up = False
                
                # Draw line segments
                for i in range(1, len(line.points)):
                    point = line.points[i]
                    gcode.append(f'G1 X{point.x:.3f} Y{point.y:.3f} F{self.settings.get("feed_rate_draw")}')
                
                last_point = line.points[-1]
        
        # Footer - pen up and return home
        gcode.append('')
        gcode.append('; End of drawing')
        gcode.append(self.settings.get_pen_up_command())
        gcode.append(f'G0 X0 Y0 F{self.settings.get("feed_rate_travel")} ; Return home')
        
        return gcode
    
    def gcode_to_turtle(self, gcode: List[str]) -> Turtle:
        """Parse G-code back into a Turtle for preview."""
        turtle = Turtle()
        
        current_x = 0.0
        current_y = 0.0
        pen_down = False
        absolute_mode = True
        
        for line in gcode:
            line = line.strip()
            
            # Skip empty lines and comments
            if not line or line.startswith(';'):
                continue
            
            # Remove inline comments
            if ';' in line:
                line = line[:line.index(';')].strip()
            
            # Parse command
            parts = line.upper().split()
            if not parts:
                continue
            
            cmd = parts[0]
            params = self._parse_params(parts[1:])
            
            if cmd == 'G0' or cmd == 'G00':
                # Rapid move (pen up implied)
                if pen_down:
                    turtle.pen_up_cmd()
                    pen_down = False
                
                if 'X' in params:
                    current_x = params['X'] if absolute_mode else current_x + params['X']
                if 'Y' in params:
                    current_y = params['Y'] if absolute_mode else current_y + params['Y']
                
                turtle.position.x = current_x
                turtle.position.y = current_y
                
            elif cmd == 'G1' or cmd == 'G01':
                # Linear move (pen down)
                if not pen_down:
                    turtle.pen_down()
                    pen_down = True
                
                if 'X' in params:
                    current_x = params['X'] if absolute_mode else current_x + params['X']
                if 'Y' in params:
                    current_y = params['Y'] if absolute_mode else current_y + params['Y']
                
                turtle.move_to(current_x, current_y)
                
            elif cmd == 'G90':
                # Absolute mode
                absolute_mode = True
                
            elif cmd == 'G91':
                # Relative mode
                absolute_mode = False
                
            elif cmd == 'M280':
                # Servo control - detect pen up/down
                if 'S' in params:
                    angle = params['S']
                    up_angle = self.settings.get('pen_angle_up')
                    down_angle = self.settings.get('pen_angle_down')
                    
                    if abs(angle - up_angle) < abs(angle - down_angle):
                        if pen_down:
                            turtle.pen_up_cmd()
                            pen_down = False
                    else:
                        if not pen_down:
                            turtle.pen_down()
                            pen_down = True
        
        return turtle
    
    def _parse_params(self, parts: List[str]) -> dict:
        """Parse G-code parameters."""
        params = {}
        for part in parts:
            if len(part) > 1:
                letter = part[0]
                try:
                    value = float(part[1:])
                    params[letter] = value
                except ValueError:
                    pass
        return params
    
    def _distance(self, p1: Point, p2: Point) -> float:
        """Calculate distance between two points."""
        dx = p2.x - p1.x
        dy = p2.y - p1.y
        return (dx * dx + dy * dy) ** 0.5

